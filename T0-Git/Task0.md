# Task0 - Git

## Task description
Склонировать один и тот же репозиторий к себе на компьютер в две разные папки. Сделать одни и те же изменения в обеих копиях репозитория, закоммитить и сделать ```push```, ```pull```. Добиться одинаковых hash сумм для обоих коммитов за счет идентичности коммитов. Сделать ```push```, ```pull```.
## Report

**Вносим одни и те же изменения, но в разных копиях репозиториев.**
При попытке ```push``` гит выдает ошибку, поскольку с точки зрения системы из-за разности хешей коммитов - это коммиты, содержащие разную информацию и, возможно, какие-либо изменения.
При вызове команды ```pull``` гит выполняет ```merge``` c нулевым diff'ом. 

**Добиваемся идентичности коммитов.**
Для идентичности коммитов необходимо совпадение двух дат:
- Дата создания ```git commit —amend —no-edit —date="2020.01.02 14:00"```
- Дата изменения ```GIT_COMMITTER_DATE="Thu Jan 2 14:00:00 2020 +0300" git commit —amend —no-edit```

При попытке ```push``` или ```pull```, при условии идентичности коммитов, один из которых уже отправлен в удаленный репо, гит в локальном репозитории смещает указатель ориджин/мастера на коммит, хеш сумма которого совпадает с тем, что в репо, предполагая, что необходимые изменения внесены и репозитории синхронизированы друг с другом. 

**Дополнительная информация о SHA-1 (используется в гите) коллизиях:**

[А что если?... Stackoverflow](https://stackoverflow.com/questions/9392365/how-would-git-handle-a-sha-1-collision-on-a-blob)

*Не актуально* на данный момент, гит закрывает уязвимости + помимо чистого SHA-1 используется техническая информация (напр. дата).
Если сократить длину SHA-1 с 160 до 4 и пересобрать гит для исследования этого являения, то обнаружится:
1. Если BLOB или tree object уже существует с таким хешем, то вы не получите каких-либо предупреждений. Однако, если попытаться выполнить ```push``` или ```revert``` вы потеряете какие-либо последние изменения. 
2. Если tree object уже существует и вы создадите blob с одинаковым хешем, то все будет хорошо до тех пор, пока вы не сделаете ```push``` или кто-то попытается склонировать ваш репо. Вы обнаружите, что репо поврежден.
3. Если commit object уже существует, то блоба с идентичным хешом приведет также к повреждению.
4. Если существует blob, и вы создаете commit object с тем же хэшем, он не будет обновляться при обновлении "ref".

Для пункта 2 и 4 при ```git push```
```
error: object 0400000000000000000000000000000000000000 is a tree, not a blob
fatal: bad blob object
error: failed to push some refs to origin

error: unable to read sha1 file of file.txt (0400000000000000000000000000000000000000)
```

5. Если существует blob и вы попытаетесь создать tree object c таким же хешем, то при создании коммита возникнет ошибка.
6. Аналогичная ситуация пункту 4 при попытке создать tree object и commit object с одинаковым хешем.
7. Если объект дерева уже существует, и вы создаете объект дерева с тем же хешем, все будет выглядеть нормально. Однако, при коммите все репозитории будут ссылаться не на то дерево.
8. **Если существует commit object, и вы создаете commit object с тем же хешем, то при вызове команды создания коммита, новый никогда не будет создан, а указатель HEAD будет перемещен к старому коммиту с таким же хешем.**
9. Если существует commit object и вы создаете tree object с таким же хешем, то получите ошибку при создании коммита.
